<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Visualization</title>
  <link id="visstyles" rel="stylesheet" href="visualizationstyles.css">
  <link rel="stylesheet" href="styles.css">

  <script src="webcomponents-hi-sd-ce.js"></script>
  <script src="jscolor.js"></script>
  <script src="d3.js"></script>
  <script src="visualization-bundle.js"></script>

  <link rel="import" href="menu.html">
</head>
<body>

<visualization-menu id='filter-menu'></visualization-menu>

<svg id="tester">
  <text></text>
</svg>
<div>
  <button id="showHideFilter" onclick="changeFilterVisibility()">Show filter</button>
  <button id="showHideMenu" onclick="changeMenuVisibility()">Show menu</button>
  <button id="showHideDeps" onclick="changeDepsVisibility()">Show detailed dependencies</button>
</div>
<div id="filters">
  <div class="forms">
    <form id="filterbyname" action="#" onsubmit="return filterByName(this);" onreset="return resetFilterByName();">
      <fieldset class="inputs">
        <legend>Filter-String:</legend>
        <input type="text" name="filter"><br>
        <input type="checkbox" name="matchCase">match case
      </fieldset>
      <fieldset class="inputs">
        <legend>Filter by:</legend>
        <input type="radio" name="filterBy" value="simplename" checked>simplename<br>
        <input type="radio" name="filterBy" value="fullname">fullname
      </fieldset>
      <fieldset class="inputs">
        <legend>What to filter:</legend>
        <input type="radio" name="whatToFilter" value="filterClassesAndEliminatePkgs" checked>
        filter classes and eliminate packages without matching classes<br>
        <input type="radio" name="whatToFilter" value="filterPkgsOrClasses">filter the following:
        <fieldset class="subinputs">
          <input type="checkbox" name="filterPackages" value="packages">packages<br>
          <input type="checkbox" name="filterClasses" value="classes">classes
        </fieldset>
      </fieldset>
      <fieldset class="inputs">
        <legend>How to filter:</legend>
        <input type="radio" name="howToFilter" value="inclusive" checked>inclusive<br>
        <input type="radio" name="howToFilter" value="exclusive">exclusive<br>
      </fieldset>
    </form>
    <form id="filterbytype" action="#" onsubmit="return filterByType(this);" onreset="return resetFilterByType();">
      <fieldset class="inputs">
        <legend>Show classes:</legend>
        <input type="checkbox" name="showInterfaces" value="interfaces" checked>
        interfaces<br>
        <input type="checkbox" name="showClasses" value="classes" checked>
        classes<br>
        <input type="checkbox" name="eliminatePkgs" value="eliminatePkgs" checked>
        eliminate packages<br>
      </fieldset>
    </form>
    <form id="filterdepsbykind" action="#" onsubmit="return filterDepsByKind(this);"
          onreset="return resetFilterDepsByKind();">
      <fieldset class="inputs">
        <legend>Show dependencies:</legend>
        <input type="checkbox" name="showImplementing" value="implementing" checked>
        implementing<br>
        <input type="checkbox" name="showExtending" value="extending" checked>
        extending<br>
        <input type="checkbox" name="showConstructorCall" value="constructorCall" checked>
        constructor call<br>
        <input type="checkbox" name="showMethodCall" value="methodCall" checked>
        method call<br>
        <input type="checkbox" name="showFieldAccess" value="fieldAccess" checked>
        field access<br>
        <input type="checkbox" name="showAnonImpl" value="anonImpl" checked>
        anonymous implementation<br>
        <input type="checkbox" name="showChildParentDep" value="childParent">
        between parent and children<br>
      </fieldset>
    </form>
  </div>
  <div class="submitbuttons">
    <div class="submit">
      <input form="filterbyname" type="reset" value="Reset" class="button">
      <input form="filterbyname" type="submit" value="Submit" class="button">
    </div>
    <div class="submit">
      <input form="filterbytype" type="reset" value="Reset" class="button">
      <input form="filterbytype" type="submit" value="Submit" class="button">
    </div>
    <div class="submit">
      <button form="filterdepsbykind" type="button" onclick="hideAllDeps()" class="button">Hide all</button>
      <input form="filterdepsbykind" type="reset" value="Reset" class="button">
      <input form="filterdepsbykind" type="submit" value="Submit" class="button">
    </div>
  </div>
</div>
<div id="menu">
  <div class="forms">
    <form id="colormenu" action="#" onsubmit="return applyColorMenu(this);">
      <fieldset class="inputs">
        <legend>Colors and styles:</legend>
        package color:
        <input class="jscolor" name="pkgColor" value="FF0000"><br>
        package opacity:
        <input type="number" name="pkgOpacity" value="0.25" min="0" max="1" step="0.01"><br>
        class color:
        <input class="jscolor" name="classColor" value="98AFC7"><br>
        class opacity:
        <input type="number" name="classOpacity" value="0.5" min="0" max="1" step="0.01"><br>
        method call:
        <input class="jscolor" name="methodcallColor" value="0000FF"><br>
        field access:
        <input class="jscolor" name="fieldaccessColor" value="FFFF00"><br>
        constructor call:
        <input class="jscolor" name="constructorcallColor" value="FF0000"><br>
        anonymous implementation:
        <input class="jscolor" name="anonimplColor" value="00FFCC">
        dashed line:
        <input class="number" name="anonimplDashed" value="1" min="1" max="10" step="1"><br>
        children access (access of the inner classes of a class):
        <input class="jscolor" name="childrenAccess" value="8B4513;"><br>
        grouped accesses:
        <input class="jscolor" name="severalColor" value="808080"><br>
      </fieldset>
    </form>
    <form id="depmenu" action="#" onsubmit="return applyDepMenu(this);">
      <fieldset class="inputs">
        <legend>Edge settings:</legend>
        Click-area width for edges:
        <input class="number" name="clickareaWidth" value="10" min="0" max="50" step="1"><br>
        Font-size for edge titel:
        <input class="number" name="edgefontsize" value="12" min="0" max="50" step="1"><br>
      </fieldset>
    </form>
    <form id="othermenu" action="#" onsubmit="return applyOtherMenu(this);">
      <fieldset class="inputs">
        <legend>Other settings (relayout on submit!):</legend>
        Font-size for circle text:
        <input class="number" name="circfontsize" width="30" value="12" min="0" max="50" step="1"><br>
        Padding between circles:
        <input class="number" name="circpadding" value="10" min="0" step="1"><br>
      </fieldset>
    </form>
  </div>
  <div class="submitbuttons">
    <div class="submit">
      <input form="colormenu" type="reset" value="reset" class="button">
      <input form="colormenu" type="submit" value="submit" class="button">
    </div>
    <div class="submit">
      <input form="depmenu" type="reset" value="reset" class="button">
      <input form="depmenu" type="submit" value="submit" class="button">
    </div>
    <div class="submit">
      <button form="othermenu" type="button" onclick="relayout()" class="button">Relayout</button>
      <input form="othermenu" type="reset" value="reset" class="button">
      <input form="othermenu" type="submit" value="submit" class="button">
    </div>
  </div>
</div>
<div id="container">
  <div id="detailedDeps">
    <h2 id="headerDetailedDeps">Detailed dependencies:</h2>
    <ul></ul>
  </div>
  <div id="svgContainer">
    <svg width="960" height="960" id="visualization"></svg>
  </div>
</div>
<script>
  window.addEventListener('WebComponentsReady', function () {
    document.querySelector('#filter-menu').onFilterChanged(filterBy => console.log(`Should filter by ${filterBy}`));
  });

  // FIXME: Eliminate 'must match' with CSS. We could fill a CSS template, or look at using CSS variables and accessing them from JS
  // FIXME: Also try to use cascading or variables for things that must match in CSS. At least the many font-size: 12px look suspicious,
  //        is this still working, if I only change one font-size??

  // must match the fontsize in the CSS-declaration
  let fontSize = 12;
  //padding between the text in a circle and the rim of the circle
  const CIRCLE_TEXT_PADDING = 5;
  //minimum padding between the circles
  const CIRCLE_PADDING = 10;

  //defines after which proportion of the circle the text is positioned; only affects nodes
  const RELATIVE_TEXT_POSITION = 0.8;
  //padding between a line and its title
  const TEXT_PADDING = 5;
  //the width of the click area of the lines
  let clickAreaWidth = 10;

  const TRANSITION_DURATION = 300;
  const APPEAR_DURATION = 10;

  const jsonToGraph = require('visualization').jsonToGraph;
  const visualizer = require('visualization').visualizer;

  let graph;
  let depWithCurrentDetailedDeps;

  const svg = d3.select("#visualization"),
      gTree = svg.append("g").attr("transform", "translate(2,2)"),
      gEdges = svg.append("g").attr("transform", "translate(2,2)");

  let textWidth = text => {
    d3.select("#tester").style("display", "inline");
    let tester = d3.select("#tester").select("text");
    tester.text(text);
    tester.style("font-size", fontSize);
    let width = tester.node().getBBox().width;
    d3.select("#tester").style("display", "none");
    return width;
  };

  visualizer.setStyles(textWidth, CIRCLE_TEXT_PADDING, RELATIVE_TEXT_POSITION, CIRCLE_PADDING, d3.packSiblings, d3.packEnclose);

  d3.json("classes.json", function (error, jsonroot) {
    if (error) throw error;
    graph = jsonToGraph(jsonroot);
    layout();
    initializeGraph();
    graph.foldAllNodes(n => visualizer.updateOnFolding(graph));
    updateWholeVisualization(false);
    initializeFilter();
  });

  function initializeFilter() {
    graph.filterDependenciesByKind()
        .showImplementing(true)
        .showExtending(true)
        .showConstructorCall(true)
        .showMethodCall(true)
        .showFieldAccess(true)
        .showAnonymousImplementing(true)
        .showDepsBetweenChildAndParent(false);
    updateEdges(d => true);
    // FIXME: Is there no way around this quasi global variable 'depWithCurrentDetailedDeps'?? Makes code hard to comprehend and extend...
    showDetailedDepsOf(depWithCurrentDetailedDeps);
  }

  function layout() {
    visualizer.visualizeGraph(graph);
    adaptSVGSize();
  }

  function adaptSVGSize(animation) {
    svg.attr("width", 2 * graph.root.visualData.r + 4);
    svg.attr("height", 2 * graph.root.visualData.r + 4);
  }

  function initializeGraph() {
    initializeTree();
    initializeDeps();
  }

  function setVisible(selection, value) {
    selection.each(x => x.visualData.visible = value);
  }

  function initializeTree() {
    let nodes =
        gTree.selectAll()
            .data(graph.getVisibleNodes())
            .enter()
            .append("g")
            .attr("class", d => d.getClass())
            .attr("transform", d => "translate(" + d.visualData.x + "," + d.visualData.y + ")");

    setVisible(nodes, true);

    let drag = d3.drag().on("drag", d => {
      visualizer.drag(graph, d, d3.event.dx, d3.event.dy, false);
      updateVisualizationAfterDragging(d);
    });

    nodes
        .filter(d => !d.isRoot())
        .on("click", d => {
          if (graph.changeFoldStateOfNode(d)) {
            visualizer.updateOnFolding(graph);
            updateVisualizationAfterFold(d);
          }
        })
        .call(drag);

    nodes
        .filter(d => !d.isRoot())
        .append("circle")
        .attr("r", d => d.visualData.r)
        .filter(d => !d.isLeaf() && d.projectData.type !== "package")
        .style("cursor", "pointer");

    nodes
        .append("text")
        .text(d => d.projectData.name);

    nodes
        .append("title")
        .text(d => d.projectData.name);

    positionTextOfAllNodes(nodes, false);
  }

  function isVisible(d) {
    return d3.select(this).style("visibility") === "visible";
  }

  function initializeDeps() {
    const defs = svg.append("defs");
    const marker = defs.append("marker")
        .attr("id", "end_arrow")
        .attr("viewBox", '0 -5 10 10')
        .attr("refX", 10)
        .attr("markerWidth", 10)
        .attr("markerHeight", 10)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5");

    let edges = gEdges.selectAll().data(graph.getVisibleDependencies()).enter();
    createNewEdges(edges, null, false);
  }

  function showDetailedDepsOf(dependency) {
    if (dependency) {
      d3.select("#detailedDeps").select("h2").text(d => "Detailed dependencies: " + dependency.from + "->" + dependency.to);
      let detailedDeps = d3.select("#detailedDeps").select("ul").selectAll("li").data(graph.getDetailedDependenciesOf(dependency.from, dependency.to));
      detailedDeps.exit().remove();
      detailedDeps.attr("class", d => d.cssClass).text(d => d.description);
      detailedDeps.enter().append("li").attr("class", d => d.cssClass).text(d => d.description);
    }
  }

  function createNewEdges(selection) {
    let newEdges = selection.append("g");

    setVisible(newEdges, true);

    newEdges
        .append("line")
        .attr("id", "dep")
        .attr("class", e => e.getClass())
        .attr("x1", e => e.visualData.startPoint.x)
        .attr("y1", e => e.visualData.startPoint.y)
        .attr("x2", e => e.visualData.endPoint.x)
        .attr("y2", e => e.visualData.endPoint.y);

    newEdges
        .filter(e => e.description.hasDetailedDescription())
        .append("line")
        .attr("id", "area")
        .attr("class", "area")
        .style("visibility", "hidden")
        .style("pointer-events", "all")
        .style("stroke-width", clickAreaWidth)
        .style("stroke", "yellow")
        .attr("x1", e => e.visualData.startPoint.x)
        .attr("y1", e => e.visualData.startPoint.y)
        .attr("x2", e => e.visualData.endPoint.x)
        .attr("y2", e => e.visualData.endPoint.y)
        .on("click", function (e) {
          depWithCurrentDetailedDeps = e;
          let t = d3.select(d3.select(this).node().parentNode).select("text");
          if (e.description.hasDescription()) {
            t.style("visibility", t.style("visibility") === "hidden" ? "inherit" : "hidden");
          }
          if (!e.description.hasDescription() || t.style("visibility") !== "hidden") {
            showDetailedDepsOf(e);
          }
        });

    newEdges
        .append("title")
        .text(e => e.description.getDescription());

    newEdges
        .filter(e => e.description.hasDescription())
        .append("text")
        .attr("class", e => e.getClass())
        .text(e => e.description.getDescription())
        .style("visibility", "hidden")
        .attr("transform", e => e.visualData.getEdgesTitleTranslation(TEXT_PADDING));
  }

  function positionTextOfAllNodes(selection, animate, transition) {
    if (animate) {
      transition.filter(d => d.visualData.visible).select("text").attr("dy", getDy);
      selection.filter(d => !d.visualData.visible).select("text").attr("dy", getDy);
    }
    else {
      selection.select("text").attr("dy", getDy);
    }
  }

  function getDy(d) {
    if (d.isRoot()) {
      return -d.visualData.r + fontSize;
    }
    else if (d.isCurrentlyLeaf()) {
      return 0;
    }
    else {
      let textDom = d3.select(this).node();
      let r = d.visualData.r;
      return computeTextShift(r, textDom.getBBox().width);
    }
  }

  /**
   * computes the greatest possible shift in y-direction of the text, so that the text is still in the circle
   **/
  function computeTextShift(r, width) {
    let shift = Math.sqrt(Math.pow(r, 2) - Math.pow(width / 2, 2));
    shift = -shift + fontSize;
    return shift;
  }

  function updateVisualizationAfterDragging(node) {
    gTree.selectAll("g").filter(d => d.isChildOf(node)).attr("transform", d => "translate(" + [d.visualData.x, d.visualData.y] + ")");
    updateEdgePosition(gEdges.selectAll("g").filter(d => d.from.startsWith(node.projectData.fullname)
    || d.to.startsWith(node.projectData.fullname)), false, () => {
    });
  }

  function updateVisualizationAfterFold(node) {
    updateVisualization(d => true, true); //ursprünglich: d => d.isChildOf(node)
  }

  function updateWholeVisualization(animate) {
    updateVisualization(d => true, animate);
  }

  function updateVisualization(filter, animate) {
    adaptSVGSize();
    updateNodes(filter, animate);
    updateEdges(filter, animate);
  }

  function setPositionAndRadius(selection) {
    selection.attr("transform", d => "translate(" + [d.visualData.x, d.visualData.y] + ")");
    selection.select("circle").attr("r", d => d.visualData.r);
  }

  function updateNodes(filter, animate) {
    let nodes = gTree.selectAll("g").data(graph.getVisibleNodes(), graph.nodeKeyFunction());

    nodes.exit().style("visibility", "hidden");
    setVisible(nodes.exit(), false);

    let filteredNodes = nodes.filter(filter);
    let transition = filteredNodes.transition().duration(TRANSITION_DURATION);

    if (animate) {
      setPositionAndRadius(transition.filter(d => d.visualData.visible));
      setPositionAndRadius(filteredNodes.filter(d => !d.visualData.visible));
      transition.transition().duration(APPEAR_DURATION).style("visibility", "visible");
    }
    else {
      setPositionAndRadius(filteredNodes);
      filteredNodes.style("visibility", "visible");
    }

    positionTextOfAllNodes(filteredNodes, animate, transition);

    setVisible(nodes, true);
  }

  function updateEdges(filter, animate) {
    let edges = gEdges.selectAll("g").data(graph.getVisibleDependencies(), graph.dependencyKeyFunction());
    hideEdges(edges.exit());
    setVisible(edges.filter(function (d) {
      return d3.select(this).style("visibility") === "visible";
    }), true);

    let callback = () => {
      showEdges(edges);
      createNewEdges(edges.enter());
    };

    updateEdgePosition(edges.filter(d => filter(d.getStartNode()) || filter(d.getEndNode())), animate, callback);
  }

  function hideEdges(edges) {
    setVisible(edges, false);
    edges.style("visibility", "hidden");
    edges.select("#area").style("pointer-events", "none");
  }

  function showEdges(edges) {
    edges.style("visibility", "visible");
    edges.select("line").attr("class", e => e.getClass());
    edges.select("#area").style("pointer-events", e => e.description.hasDetailedDescription() ? "all" : "none");
    edges.filter(e => e.description.hasDescription())
        .select("text").attr("class", e => e.getClass()).text(e => e.description.getDescription());
    edges.select("text").style("visibility", function (e) {
      if (e.description.hasDetailedDescription()) {
        return (d3.select(this).style("visibility") === "hidden") ? "hidden" : "inherit";
      }
      else {
        return "hidden";
      }
    });
  }

  function updateEdgePosition(edges, animate, callback) {
    updateLinePosition(edges, animate, callback);
    updateTitlePosition(edges, animate);
  }

  function updateLinePosition(edges, animate, callback) {
    // FIXME: Let's just decide once and for all, if we animate, or not? Why would we want to turn this off? KISS ;-)
    if (animate) {
      let n = 0;
      let deps = edges.select("#dep");
      if (deps.empty()) {
        callback();
      }
      else {
        deps.each(() => n++)
            .transition().duration(TRANSITION_DURATION) //zuerst direkt nach edges und unten nicht
        //.select("#dep")  //.filter(d => d.visualData.visible)
            .attr("x1", e => e.visualData.startPoint.x)
            .attr("y1", e => e.visualData.startPoint.y)
            .attr("x2", e => e.visualData.endPoint.x)
            .attr("y2", e => e.visualData.endPoint.y)
            .on('end', () => {
              n--;
              if (!n) {
                callback();
              }
            });
      }
      /*trans = trans.transition().duration(1);
       trans.select("#dep")
       .filter(d => !d.visualData.visible)
       .attr("x1", e => e.visualData.startPoint.x)
       .attr("y1", e => e.visualData.startPoint.y)
       .attr("x2", e => e.visualData.endPoint.x)
       .attr("y2", e => e.visualData.endPoint.y);*/
    }
    else {
      edges.select("#dep")
          .attr("x1", e => e.visualData.startPoint.x)
          .attr("y1", e => e.visualData.startPoint.y)
          .attr("x2", e => e.visualData.endPoint.x)
          .attr("y2", e => e.visualData.endPoint.y);

      callback();
    }

    edges
        .select("#area")
        .attr("x1", e => e.visualData.startPoint.x)
        .attr("y1", e => e.visualData.startPoint.y)
        .attr("x2", e => e.visualData.endPoint.x)
        .attr("y2", e => e.visualData.endPoint.y);
  }

  function updateTitlePosition(edges, animate) {
    if (animate) {
      /*let trans = edges.select("text").transition().duration(TRANSITION_DURATION);
       trans.filter(d => d.visualData.visible).attr("transform", e => e.visualData.getEdgesTitleTranslation(TEXT_PADDING));
       trans.transition().duration(1).filter(d => !d.visualData.visible).attr("transform", e => e.visualData.getEdgesTitleTranslation(TEXT_PADDING));
       */
      edges.select("text").transition().duration(TRANSITION_DURATION).attr("transform", e => e.visualData.getEdgesTitleTranslation(TEXT_PADDING));
    }
    else {
      edges.select("text").attr("transform", e => e.visualData.getEdgesTitleTranslation(TEXT_PADDING));
    }
  }

  function filterByName(form) {
    graph.filterNodesByName(form.filter.value)
        .by()[form.filterBy.value]()
        [form.whatToFilter.value](form.filterPackages.checked, form.filterClasses.checked)
        [form.howToFilter.value]()
        .matchCase(form.matchCase.checked);

    updateWholeVisualization(false);
    return false;
  }

  function resetFilterByName() {
    graph.resetFilterNodesByName();
    updateWholeVisualization(false);
  }

  function filterByType(form) {
    graph.filterNodesByType(form.showInterfaces.checked, form.showClasses.checked, form.eliminatePkgs.checked);
    updateWholeVisualization(false);
    return false;
  }

  function resetFilterByType() {
    graph.resetFilterNodesByType();
    updateWholeVisualization(false);
  }

  function filterDepsByKind(form) {
    graph.filterDependenciesByKind()
        .showImplementing(form.showImplementing.checked)
        .showExtending(form.showExtending.checked)
        .showConstructorCall(form.showConstructorCall.checked)
        .showMethodCall(form.showMethodCall.checked)
        .showFieldAccess(form.showFieldAccess.checked)
        .showAnonymousImplementing(form.showAnonImpl.checked)
        .showDepsBetweenChildAndParent(form.showChildParentDep.checked);
    updateEdges(d => true);
    showDetailedDepsOf(depWithCurrentDetailedDeps);
    return false;
  }

  function hideAllDeps() {
    graph.filterDependenciesByKind()
        .showImplementing(false).showExtending(false)
        .showConstructorCall(false).showMethodCall(false).showFieldAccess(false).showAnonymousImplementing(false);
    updateEdges(d => true);
    return false;
  }

  function resetFilterDepsByKind() {
    graph.resetFilterDependenciesByKind();
    updateEdges(d => true);
  }

  function changeFilterVisibility() {
    let filters = d3.select("#filters");
    filters.style("display", () => filters.style("display") === "none" ? "table" : "none");
    d3.select("#showHideFilter").text(() => filters.style("display") === "none" ? "Show filter" : "Hide filter");
  }

  function changeMenuVisibility() {
    let menu = d3.select("#menu");
    menu.style("display", () => menu.style("display") === "none" ? "table" : "none");
    d3.select("#showHideMenu").text(() => menu.style("display") === "none" ? "Show menu" : "Hide menu");
  }

  function changeDepsVisibility() {
    let detailedDeps = d3.select("#detailedDeps");
    detailedDeps.style("display", () => detailedDeps.style("display") === "none" ? "inline-block" : "none");
    d3.select("#showHideDeps").text(() => detailedDeps.style("display") === "none" ? "Show detailed dependencies" : "Hide detailed dependencies");
  }

  function getRule(sheet, selectorText) {
    for (let i = 0; i < sheet.cssRules.length; i++) {
      if (sheet.cssRules[i].selectorText === selectorText) {
        return i;
      }
    }
    return -1;
  }

  function setRule(sheet, selectorText, value) {
    let index = getRule(sheet, selectorText);
    sheet.deleteRule(index);
    sheet.insertRule(selectorText + " " + value, index);
  }

  function applyColorMenu(form) {
    let visstyles = document.getElementById("visstyles");
    let sheet = visstyles.sheet || visstyles.stylesheet;
    setRule(sheet, '.package circle', '{ fill: #' + form.pkgColor.value + '; fill-opacity: ' + form.pkgOpacity.value + ';}');
    setRule(sheet, '.class circle, .abstractclass circle, .interface circle', '{ fill: #' + form.classColor.value
        + '; fill-opacity: ' + form.classOpacity.value + ';}');

    setRule(sheet, 'line.methodCall', '{ stroke: #' + form.methodcallColor.value + ';}');
    setRule(sheet, 'line.fieldAccess', '{ stroke: #' + form.fieldaccessColor.value + ';}');
    setRule(sheet, 'line.constructorCall', '{ stroke: #' + form.constructorcallColor.value + ';}');
    setRule(sheet, 'line.implementsAnonymous', '{  stroke-dasharray: ' + form.anonimplDashed.value + ', '
        + form.anonimplDashed.value + '; stroke: #' + form.anonimplColor.value + ';}');
    setRule(sheet, 'line.childrenAccess', '{ stroke: #' + form.childrenAccess.value + ';}');

    setRule(sheet, 'li.methodCall', '{ color: #' + form.methodcallColor.value + ';}');
    setRule(sheet, 'li.fieldAccess', '{ color: #' + form.fieldaccessColor.value + ';}');
    setRule(sheet, 'li.constructorCall', '{ color: #' + form.constructorcallColor.value + ';}');
    setRule(sheet, 'li.implementsAnonymous', '{  border: dotted ' + form.anonimplDashed.value + 'px black; ' +
        'border-color: #' + form.anonimplColor.value + ';}');

    setRule(sheet, 'line.several', '{ stroke: #' + form.severalColor.value + ';}');
    return false;
  }

  function applyDepMenu(form) {
    clickAreaWidth = form.clickareaWidth.value;
    gEdges.selectAll("g").select("#area").style("stroke-width", clickAreaWidth);
    let visstyles = document.getElementById("visstyles");
    let sheet = visstyles.sheet || visstyles.stylesheet;
    setRule(sheet, 'text.access', '{ font-weight: normal; font-size: ' + form.edgefontsize.value + 'px; }');
    return false;
  }

  function applyOtherMenu(form) {
    fontSize = parseInt(form.circfontsize.value);
    let visstyles = document.getElementById("visstyles");
    let sheet = visstyles.sheet || visstyles.stylesheet;
    setRule(sheet, '.package text, .interface text, .abstractclass text, .class text', '{ font-size: ' + fontSize + 'px; }');
    visualizer.setCirclePadding(parseInt(form.circpadding.value));
    layout();
    updateWholeVisualization(true);
    return false;
  }

  function relayout() {
    layout();
    updateWholeVisualization(true);
  }
</script>
</body>
</html>