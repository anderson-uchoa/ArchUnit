<!DOCTYPE html>
<meta charset="utf-8">
<style>

  .links line {
    stroke: #999;
    stroke-opacity: 0.6;
  }

  .nodes circle {
    stroke: #fff;
    stroke-width: 1.5px;
  }

</style>
<svg width="2000" height="1000"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

  var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height");

  const rootRadius = 400;
  const rootX = width/2;
  const rootY = height/2;

  const arrNodesOut = ["Gervais", "Tholomyes"];


  svg.append("g")
    .attr("class", "nodes")
    .append("circle")
    .attr("r", rootRadius)
    .attr("cx", rootX)
    .attr("cy", rootY)
    .attr("fill", "yellow");

  var color = d3.scaleOrdinal(d3.schemeCategory20);

  const distance = 10;

  var simulation = d3.forceSimulation()
    .force("link", d3.forceLink().id(function (d) {
      return d.id;
    })
      .distance(d => {
        return d.source.r + d.target.r + distance; //
      })
    .iterations(2))
    //.force("charge", d3.forceManyBody().strength(-100))
    .force("collide", d3.forceCollide().radius(d => d.r + distance).iterations(2))
    .force("center", d3.forceCenter(width / 2, height / 2));

  var dragSimulation = d3.forceSimulation()
    .force("collide", d3.forceCollide().radius(d => d.r + distance)) //.iterations(10))
    .stop();

  let link;
  let node;

  let allNodes;

  d3.json("example.json", function (error, graph) {
    if (error) throw error;

    allNodes = graph.nodes;

    graph.nodes.forEach(n => n.r = 5 + 30 * Math.random());

    link = svg.append("g")
      .attr("class", "links")
      .selectAll("line")
      .data(graph.links)
      .enter().append("line")
      .attr("stroke-width", function (d) {
        return Math.sqrt(d.value);
      });

    node = svg.append("g")
      .attr("class", "nodes")
      .selectAll("circle")
      .data(graph.nodes)
      .enter().append("circle")
      .attr("r", n => n.r)
      .attr("fill", function (d) {
        if (arrNodesOut.includes(d.id)) return "black";
        return color(d.group);
      })
      .call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));

    node.append("title")
      .text(function (d) {
        return d.id;
      });

    simulation
      .nodes(graph.nodes)
      .on("tick", ticked);
      //.on('end', ticked);

    simulation.force("link")
      .links(graph.links);

    dragSimulation.nodes(graph.nodes).alphaTarget(0.3).on('tick', ticked);
  });

  const getStartPositionOfDep = (dep, getStart, getEnd) => {
    const radius = getStart(dep).r;
    const directionVector = {
      x: getEnd(dep).x - getStart(dep).x,
      y: getEnd(dep).y - getStart(dep).y
    };
    const directionVectorLength = Math.sqrt(directionVector.x * directionVector.x + directionVector.y * directionVector.y);
    const normedDirectionVector = {
      x: radius * directionVector.x / directionVectorLength,
      y: radius * directionVector.y / directionVectorLength
    };
    return {
      x: getStart(dep).x + normedDirectionVector.x,
      y: getStart(dep).y + normedDirectionVector.y
    };
  };

  function ticked() {
    //keeps all nodes within the root node
    const length = n => Math.sqrt(n.x*n.x + n.y*n.y);
    allNodes.filter(n => !arrNodesOut.includes(n.id)).forEach(n => {
      const direction = {x: n.x - rootX, y: n.y - rootY};
      const dirLength = length(direction);

      if (dirLength + n.r >= rootRadius) {
        const scale = rootRadius - n.r;
        const normedDirection = {x: scale * direction.x / dirLength, y: scale * direction.y / dirLength};
        n.x = rootX + normedDirection.x;
        n.y = rootY + normedDirection.y;
      }
    });

    link
      .attr("x1", function (d) {
        const currentCoords = getStartPositionOfDep(d, d => d.source, d => d.target);
        return currentCoords.x;
      })
      .attr("y1", function (d) {
        const currentCoords = getStartPositionOfDep(d, d => d.source, d => d.target);
        return currentCoords.y;
      })
      .attr("x2", function (d) {
        const currentCoords = getStartPositionOfDep(d, d => d.target, d => d.source);
        return currentCoords.x;
      })
      .attr("y2", function (d) {
        const currentCoords = getStartPositionOfDep(d, d => d.target, d => d.source);
        return currentCoords.y;
      });

    node
      .attr("cx", function (d) {
        return d.x;
      })
      .attr("cy", function (d) {
        return d.y;
      });
  }

  function dragstarted(d) {
    /*d.fx = d.x;
    d.fy = d.y;

    if (!d3.event.active) dragSimulation.alphaTarget(0.1).alpha(1).restart(); //.on('tick', ticked)*/
    d.fx = d.x;
    d.fy = d.y;

    //dragSimulation.restart();

  }

  function dragged(d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
    simulation.alphaDecay(0).alpha(0.09).restart(); //alphaTarget(0.3)
    //simulation.alpha(1).restart();


    //if (!d3.event.active) dragSimulation.alpha(1).restart();
  }

  function dragended(d) {
    /*dragSimulation.alphaTarget(0).on('end', () => {
      d.fx = null;
      d.fy = null;
    });*/

    /*simulation.stop();
    simulation.alphaDecay(0.01)
    simulation.alpha(0.01);
    for (let i = 0, n = Math.ceil(Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay())); i < n; ++i) {
      simulation.tick();
    }
    ticked();*/

    //dragSimulation.stop();
    if (!d3.event.active) simulation.alphaDecay(0.01).alphaTarget(0);

    d.fx = null;
    d.fy = null;

    //simulation.alpha(0.5).restart();
    simulation.on('end', () => {
      d.fx = null;
      d.fy = null;
    });
  }

</script>