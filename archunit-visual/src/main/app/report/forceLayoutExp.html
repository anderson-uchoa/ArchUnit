<!DOCTYPE html>
<meta charset="utf-8">
<style>

  .links line {
    stroke: #999;
    stroke-opacity: 0.6;
  }

  .nodes circle {
    stroke: #fff;
    stroke-width: 1.5px;
  }

</style>
<svg width="2000" height="1000"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

  var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height");

  const rootRadius = 400;
  const rootX = width / 2;
  const rootY = height / 2;
  const rootId = "Gervais";

  const arrNodesOut = ["Tholomyes", "Zephine"];


  /*svg.append("g")
   .attr("class", "nodes")
   .append("circle")
   .attr("r", rootRadius)
   .attr("cx", rootX)
   .attr("cy", rootY)
   .attr("fill", "yellow");*/

  var color = d3.scaleOrdinal(d3.schemeCategory20);

  const distance = 10;

  const count = node => {
    return allNodes.filter(n => n === node).length;
  };

  var simulation = d3.forceSimulation()
    .force("link", d3.forceLink().id(function (d) {
      return d.id;
    })
      .distance(d => {
        return d.source.r + d.target.r + distance; //
      })
      .strength(link => {
        const res = 1 / Math.min(count(link.source), count(link.target));
        if ((arrNodesOut.includes(link.source) && !arrNodesOut.includes(link.target) && link.target.id !== rootId)
          || (arrNodesOut.includes(link.target) && !arrNodesOut.includes(link.source) && link.source.id !== rootId)) {
          return 0.1 * res;
        }
        return res;
      })
    .iterations(2));
    //.force("charge", d3.forceManyBody().strength(-100));
  var collSim1 = d3.forceSimulation()
    .force("collide", d3.forceCollide().radius(d => d.r + distance).iterations(2));

  var collSim2 = d3.forceSimulation()
    .force("collide", d3.forceCollide().radius(d => d.r + distance).iterations(2));

  //FIXME: instead of this centre all nodes after each tick
 /* var toMiddle = d3.forceSimulation()
    .force("center", d3.forceCenter(width / 2, height / 2));

  var dragSimulation = d3.forceSimulation()
    .force("collide", d3.forceCollide().radius(d => d.r + distance)) //.iterations(10))
    .stop();*/

  let link;
  let node;

  let allNodes;

  d3.json("example.json", function (error, graph) {
    if (error) {
      throw error;
    }

    allNodes = graph.nodes;

    graph.nodes.forEach(n => {
      if (n.id === rootId) {
        n.r = rootRadius;
      } else {
        n.r = 5 + 30 * Math.random()
      }
    });

    link = svg.append("g")
      .attr("class", "links")
      .selectAll("line")
      .data(graph.links)
      .enter().append("line")
      .attr("stroke-width", function (d) {
        return Math.sqrt(d.value);
      });

    node = svg.append("g")
      .attr("class", "nodes")
      .selectAll("circle")
      .data(graph.nodes)
      .enter().append("circle")
      .attr("r", n => {
        if (n.id === rootId) {
          return rootRadius;
        } else {
          return n.r
        }
      })
      .style('stroke', function (d) {
        if (d.id === rootId) {
          return "black";
        }
      })
      .attr("fill", function (d) {
        if (d.id === rootId) {
          return "none";
        }
        if (arrNodesOut.includes(d.id)) {
          return "black";
        }
        return color(d.group);
      })
      .call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));

    node.append("title")
      .text(function (d) {
        return d.id;
      });

    simulation
      .alphaDecay(0.1)
      .nodes(graph.nodes)
      .on("tick", ticked);
    //.on('end', ticked);

    simulation.force("link")
      .links(graph.links);

    collSim1
      .alphaDecay(0.1)
      .nodes(graph.nodes.filter(n => !arrNodesOut.includes(n.id) && n.id !== rootId))
      .on("tick", ticked);

    collSim2
      .alphaDecay(0.1)
      .nodes(graph.nodes.filter(n => arrNodesOut.includes(n.id) || n.id === rootId))
      .on("tick", ticked);

    /*toMiddle
      .nodes(graph.nodes.filter(n => n.id === rootId))
      .on('tick', ticked);*/

    //dragSimulation.nodes(graph.nodes).alphaTarget(0.3).on('tick', ticked);
  })
  ;

  const getStartPositionOfDep = (dep, getStart, getEnd) => {
    const radius = getStart(dep).r;
    const directionVector = {
      x: getEnd(dep).x - getStart(dep).x,
      y: getEnd(dep).y - getStart(dep).y
    };
    const directionVectorLength = Math.sqrt(directionVector.x * directionVector.x + directionVector.y * directionVector.y);
    const normedDirectionVector = {
      x: radius * directionVector.x / directionVectorLength,
      y: radius * directionVector.y / directionVectorLength
    };
    return {
      x: getStart(dep).x + normedDirectionVector.x,
      y: getStart(dep).y + normedDirectionVector.y
    };
  };

  function ticked() {
    //keeps all nodes within the root node
    const length = n => Math.sqrt(n.x * n.x + n.y * n.y);
    allNodes.filter(n => !arrNodesOut.includes(n.id) && n.id !== rootId).forEach(n => {
      const root = allNodes.filter(n => n.id === rootId)[0];
      const direction = {x: n.x - root.x, y: n.y - root.y};
      const dirLength = length(direction);

      if (dirLength + n.r >= rootRadius) {
        const scale = rootRadius - n.r;
        const normedDirection = {x: scale * direction.x / dirLength, y: scale * direction.y / dirLength};
        n.x = root.x + normedDirection.x;
        n.y = root.y + normedDirection.y;
      }
    });

    const root = allNodes.filter(n => n.id === rootId)[0];
    allNodes.forEach(n => {
      n.x -= (root.x - rootX);
      n.y -= (root.y - rootY);
    });

    link
      .attr("x1", function (d) {
        const currentCoords = getStartPositionOfDep(d, d => d.source, d => d.target);
        return currentCoords.x;
      })
      .attr("y1", function (d) {
        const currentCoords = getStartPositionOfDep(d, d => d.source, d => d.target);
        return currentCoords.y;
      })
      .attr("x2", function (d) {
        const currentCoords = getStartPositionOfDep(d, d => d.target, d => d.source);
        return currentCoords.x;
      })
      .attr("y2", function (d) {
        const currentCoords = getStartPositionOfDep(d, d => d.target, d => d.source);
        return currentCoords.y;
      });

    node
      .attr("cx", function (d) {
        return d.x;
      })
      .attr("cy", function (d) {
        return d.y;
      });
  }

  function dragstarted(d) {
    /*d.fx = d.x;
     d.fy = d.y;

     if (!d3.event.active) dragSimulation.alphaTarget(0.1).alpha(1).restart(); //.on('tick', ticked)*/
    d.fx = d.x;
    d.fy = d.y;

    //dragSimulation.restart();

  }

  function dragged(d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
    simulation.alphaDecay(0).alpha(0.09).restart(); //alphaTarget(0.3)
    collSim1.alphaDecay(0).alpha(0.09).restart();
    collSim2.alphaDecay(0).alpha(0.09).restart();
    //simulation.alpha(1).restart();


    //if (!d3.event.active) dragSimulation.alpha(1).restart();
  }

  function dragended(d) {
    /*dragSimulation.alphaTarget(0).on('end', () => {
     d.fx = null;
     d.fy = null;
     });*/

    /*simulation.stop();
     simulation.alphaDecay(0.01)
     simulation.alpha(0.01);
     for (let i = 0, n = Math.ceil(Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay())); i < n; ++i) {
     simulation.tick();
     }
     ticked();*/

    //dragSimulation.stop();
    if (!d3.event.active) {
      simulation.alphaDecay(0.01).alphaTarget(0);
      collSim1.alphaDecay(0.01).alphaTarget(0);
      collSim2.alphaDecay(0.01).alphaTarget(0);
    }

    d.fx = null;
    d.fy = null;

    //simulation.alpha(0.5).restart();
    simulation.on('end', () => {
      d.fx = null;
      d.fy = null;
    });
  }

</script>